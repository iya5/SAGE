/* SAGE: Sage Ain't A Game Engine. An OpenGL 3D Renderer.

This file is part of Sage

Sage is free software: you can redistribute it and/or modify it under the terms
of the GNU General Public License as published by the Free Software Foundation,
either version 3 of the License, or (at your option) any later version.

Sage is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with 
Sage; see the file LICENSE. If not, see <https://www.gnu.org/licenses/>.    */

#include <stdlib.h>
#include <math.h>
#include <glad/gl.h>

#include "scene.h"
#include "camera.h"
#include "darray.h"
#include "logger.h"
#include "model.h"
#include "shader.h"
#include "texture.h"

void scene_init(struct scene *scene, float viewport_width, float viewport_height)
{
    /* Allocating memory for models, materials, lighting, & shaders */
    scene->models = darray_alloc(sizeof(struct model), 32);
    scene->materials = darray_alloc(sizeof(struct model), 32);
    scene->point_lights = darray_alloc(sizeof(struct model), 32);
    scene->shaders = darray_alloc(sizeof(struct model), 32);

    if (scene->models == NULL || scene->materials == NULL
        || scene->point_lights == NULL || scene->shaders == NULL) {
        SFATAL("Failed to allocate memory for the scene");
        if (scene->models) darray_free(scene->models);
        if (scene->materials) darray_free(scene->materials);
        if (scene->point_lights) darray_free(scene->point_lights);
        if (scene->shaders) darray_free(scene->shaders);
        exit(1);
    }

    /* A scene is composed of three important components; camera,
       geometry, & lighting */
    struct camera *cam = &(scene->cam);
    float aspect = viewport_width / viewport_height;
    camera_init(cam, CAM_DEFAULT_POS, CAM_DEFAULT_FORWARD, CAM_DEFAULT_UP);
    camera_perspective(cam,
                       FOV_DEFAULT,
                       aspect,
                       PERSPECTIVE_DEFAULT_NEAR,
                       PERSPECTIVE_DEFAULT_FAR);

    /* Creating light */
    struct directional_light environment_light = {
        .direction = {0.5, -0.3, 0.5},
        .ambient = {0.3, 0.3, 0.3},
        .diffuse = {0.0, 0.0, 0.0},
        .specular = {0.0, 0.0, 0.0}
    };
    scene->environment_light = environment_light;


    
    /* Compile shaders */
    /* i need to get the ID to somehow use it when rendering but how? */
    /* the ID is actually just the index returned when pushing the darray
       giving me access to it when using darray_at() */
    const char *shader_paths[] = {
        "glsl/phong.glsl",
        "glsl/color.glsl",
        "glsl/skybox.glsl",
        "glsl/light.glsl"
    };

    for (uint32_t i = 0; i < sizeof(shader_paths); i++) {
        struct shader shader = shader_create(shader_paths[i]);
        darray_push(scene->shaders, &shader);
    }

    /* Compiling textures */
    /* Same problem of how to retrieve a specific texture when pushing it?
       and how would i able to access it when rendering? */
    const char *texture_paths[] = {
        "res/textures/base.png",
        "res/textures/container-diffuse.png",
        "res/textures/container-specular.png",
        "res/textures/uv-grid.jpg"
    };

    const char *cubemap_paths[] = {
        "res/textures/skybox/right.jpg",
        "res/textures/skybox/left.jpg",
        "res/textures/skybox/top.jpg",
        "res/textures/skybox/bottom.jpg",
        "res/textures/skybox/front.jpg",
        "res/textures/skybox/back.jpg",
    };

    for (uint32_t i = 0; i < sizeof(texture_paths); i++) {
        struct texture texture = texture_create(texture_paths[i], TEXTURE_DIFFUSE);
        /* what to do with it now */
    }

    /* create models here */


    /* Creating materials as parameters for shaders */
    
}

// TODO: refactor
void scene_render(struct scene *scene)
{
    /* pre-rendering (clearing buffers) */
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    struct camera *cam = &(scene->cam);
    camera_update(cam);

    shader_use(shaders[SHADER_LIGHT]);
    model_draw(
    mesh_bind(cube);
    texture_bind(default_texture, 0);
    transform_reset(&transform);

    transform_scale(&transform, (vec3){0.2, 0.2, 0.2});
    struct point_light *light = darray_at(scene->point_lights, 0);
    mnf_vec3_copy(
        (vec3){
            (cos(current_seconds) * 10) + 10,
            4,
            14, 
        }, light->pos
    );
    transform_position(&transform, light->pos);
    transform_model(transform, cube.model);

    shader_uniform_vec3(shaders[SHADER_LIGHT], "u_color", light->color);
    shader_uniform_mat4(shaders[SHADER_LIGHT], "u_model", cube.model);
    shader_uniform_mat4(shaders[SHADER_LIGHT], "u_view", cam->view);
    shader_uniform_mat4(shaders[SHADER_LIGHT], "u_projection", cam->projection);
    mesh_draw(cube);

    /* draw second light */
    shader_use(shaders[SHADER_LIGHT]);
    mesh_bind(cube);
    texture_bind(default_texture, 0);
    transform_reset(&transform);

    transform_scale(&transform, (vec3){0.2, 0.2, 0.2});
    struct point_light *light_2 = darray_at(scene->point_lights, 1);
    mnf_vec3_copy(
        (vec3){
            (sin(current_seconds) * 10) + 10,
            4,
            7, 
        }, light_2->pos
    );
    transform_position(&transform, light_2->pos);
    transform_model(transform, cube.model);

    /* IMPORTANT NOTE, ALWAYS SEND TRANSFORMATION MATRICES BEFORE DRAW CALL */
    shader_uniform_vec3(shaders[SHADER_LIGHT], "u_color", light_2->color);
    shader_uniform_mat4(shaders[SHADER_LIGHT], "u_model", cube.model);
    shader_uniform_mat4(shaders[SHADER_LIGHT], "u_view", cam->view);
    shader_uniform_mat4(shaders[SHADER_LIGHT], "u_projection", cam->projection);
    mesh_draw(cube);
    /* draw lit cube */
    shader_use(shaders[SHADER_PHONG]);
    mesh_bind(cube);
    texture_bind(container_diffuse, 0);
    texture_bind(container_specular, 1);
    transform_reset(&transform);

    vec3 obj_pos = {4.0, 1, 10};
    transform_scale(&transform, (vec3){2, 2, 2});
    transform_position(&transform, obj_pos);

    /* set light parameters of the light equation */
    set_light_params(shaders[SHADER_PHONG],
                     environment_light,
                     material,
                     scene.point_lights);

    transform_model(transform, cube.model);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_model", cube.model);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_view", cam->view);
    shader_uniform_vec3(shaders[SHADER_PHONG], "u_view_pos", cam.pos);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_projection", cam->projection);

    mesh_draw(cube);

    /* draw second object in scene */
    shader_use(shaders[SHADER_PHONG]);
    mesh_bind(cube);
    texture_bind(base_texture, 0);
    texture_bind(default_texture, 1);
    transform_reset(&transform);

    vec3 obj2_pos = {10, -0.5, 10};
    transform_scale(&transform, (vec3){20, 1, 20});
    transform_position(&transform, obj2_pos);

    /* set light parameters of the light equation */
    set_light_params(shaders[SHADER_PHONG],
                     environment_light,
                     material,
                     scene.point_lights);

    transform_model(transform, cube.model);
    shader_uniform_vec3(shaders[SHADER_PHONG], "u_view_pos", cam.pos);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_model", cube.model);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_view", cam.view);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_projection", cam.projection);

    mesh_draw(cube);

    /* draw third object */
    shader_use(shaders[SHADER_PHONG]);
    mesh_bind(crab);
    texture_bind(crab_texture, 0);
    texture_bind(crab_texture, 1);
    transform_reset(&transform);

    vec3 obj3_pos = {13, 3.4, 8};
    transform_scale(&transform, (vec3){2, 2, 2});
    transform_position(&transform, obj3_pos);

    /* set light parameters of the light equation */
    set_light_params(shaders[SHADER_PHONG],
                     environment_light,
                     material,
                     scene.point_lights);

    transform_model(transform, crab.model);
    shader_uniform_vec3(shaders[SHADER_PHONG], "u_view_pos", cam.pos);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_model", crab.model);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_view", cam.view);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_projection", cam.projection);

    mesh_draw(crab);

    /* draw fourth object */
    shader_use(shaders[SHADER_PHONG]);
    mesh_bind(sphere);
    transform_reset(&transform);

    vec3 obj4_pos = {8, 2, 17};
    transform_scale(&transform, (vec3){1, 1, 1});
    transform_rotation(&transform, (vec3){MNF_RAD(20), MNF_RAD(34), MNF_RAD(90)});
    transform_position(&transform, obj4_pos);

    /* set light parameters of the light equation */
    set_light_params(shaders[SHADER_PHONG],
                     environment_light,
                     glass,
                     scene.point_lights);

    transform_model(transform, sphere.model);
    shader_uniform_vec3(shaders[SHADER_PHONG], "u_view_pos", cam.pos);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_model", sphere.model);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_view", cam.view);
    shader_uniform_mat4(shaders[SHADER_PHONG], "u_projection", cam.projection);
    texture_bind(uv_grid_texture, 0);
    texture_bind(uv_grid_texture, 1);

    mesh_draw(sphere);
}

void scene_destroy(struct scene *scene)
{
    darray_free(scene->point_lights);
}
/* TODO: REFACTOR THIS FUNCTION IS OLD
void world_grid_draw(mat4 view,
                     mat4 projection,
                     struct mesh mesh,
                     struct shader shader, 
                     struct texture texture)
{
    // prolly a naive approach at drawing a world grid, could do this instead
    // in the shaders. currently implemented as drawing 3 seperate strecthed out
    // cubes representing the cardinal axis
    shader_use(shader);
    texture_bind(texture, 0);
    mesh_bind(mesh);

    struct transform transform;

    transform_reset(&transform);
    transform_scale(&transform, (vec3){200.0, 0.01, 0.01});
    transform_model(transform, mesh.model);

    shader_uniform_mat4(shader, "u_model", mesh.model);
    shader_uniform_mat4(shader, "u_view", view);
    shader_uniform_mat4(shader, "u_projection", projection);
    shader_uniform_vec4(shader, "u_color", (vec4){0.8, 0.20, 0.4, 1.0});
    mesh_draw(mesh);

    transform_reset(&transform);
    transform_scale(&transform, (vec3){0.01, 200.0, 0.01});
    transform_rotation(&transform, (vec3){0, MNF_RAD(90), 0});
    transform_model(transform, mesh.model);
    shader_uniform_mat4(shader, "u_model", mesh.model);
    shader_uniform_mat4(shader, "u_view", view);
    shader_uniform_mat4(shader, "u_projection", projection);
    shader_uniform_vec4(shader, "u_color", (vec4){0.5, 0.7, 0.25, 1.0});
    mesh_draw(mesh);

    transform_reset(&transform);
    transform_scale(&transform, (vec3){0.01, 0.01, 200.0});
    transform_rotation(&transform, (vec3){0, 0, MNF_RAD(90)});
    transform_model(transform, mesh.model);
    shader_uniform_mat4(shader, "u_model", mesh.model);
    shader_uniform_mat4(shader, "u_view", view);
    shader_uniform_mat4(shader, "u_projection", projection);
    shader_uniform_vec4(shader, "u_color", (vec4){0.3, 0.5, 0.7, 1.0});
    mesh_draw(mesh);
}
*/

/* TODO: REFACTOR. THIS FUNCTION IT'S OLD
void skybox_draw(struct shader skybox_shader, 
                 struct mesh skybox, 
                 struct texture cubemap,
                 mat4 view, 
                 mat4 projection)
{
    glDepthMask(GL_FALSE);
    shader_use(skybox_shader);
    mesh_bind(skybox);
    cubemap_texture_bind(cubemap);

    mat4 view_no_translation;
    mnf_mat4_copy(view, view_no_translation);

    view_no_translation[3][0] = 0;
    view_no_translation[3][1] = 0;
    view_no_translation[3][2] = 0;
    view_no_translation[3][3] = 1;

    shader_uniform_mat4(skybox_shader, "u_view", view_no_translation);
    shader_uniform_mat4(skybox_shader, "u_projection", projection);
    mesh_draw(skybox);
    glDepthMask(GL_TRUE);
}
*/
